/**
 * 5. 最长回文子串
 * 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
 */

 /**
  * 算是暴力破解法
  * @param {string} s
  * @return {string}
  * 思路：先计算出当前有多少成对的字母，把每个字母的位置以字母为键放到对象里，然后轮询对象，再轮询对象内的数组，检查最长的回文字串
  * 问题： 
  *      1. 数组保存的数量可能很多，轮询对象并且还必须轮询数组。
  *      2. 最长回文字串的位置不一定在数组的哪个位置，必须轮询数组的全组合，不能单纯的从数组两边向中央推进
  */
var longestPalindrome = function(s) {
    let obj = {};
    for (let i = 0; i < s.length; i++) {
        let single = s[i]
        if(obj[single]){
            obj[single].push(i);
        } else {
            obj[single] = [i];
        }
    }
    console.log(obj);
    for (const key in obj) {
        console.log(key);
        if(obj[key].length > 1) {
            while (condition) {
                
            }
        }
    }
};
longestPalindrome('babad')

/**
 * 官方题解：动态规划
 * 
 * 定理：如果一个回文串并且大于2，那么去掉首位两个字符这个串仍然是回文串
 * 
 * 用P(i,j)表示字符串s到j个字母组成的串（下文表示成s[i:j]）是否为回文串
 *
 * P(i,j) = true (是回文串)|| false(其他情况) 
 * 
 * 其他情况包含：
 *      1. s(i,j)本身不是一个回文串
 *      2. i>j,此时s(i,j)不合法
 * 
 * 这样就可以写出状态转移方程； P(i,j) = P(i+1,j-1) && (Si === Sj)
 * 
 * 也就是说，只有 s[i+1:j-1] 是回文串，并且 s的第 i和 j 个字母相同时，s[i:j] 才会是回文串。
 * 
 * 边界条件：
 * 
 * 在小于等于2的时候的字串的判断，单个字符肯定是回文串，两个字符，如果两个字符相等也是回文串
 * 
 * 那么边界条件就是： P(i,i) = true || P(i,i+1) = Si ===S(i+1)
 * 
 * 最终的答案即为 P(i,j) = true 中 j - i +1 的最大值。
 * 
 * 注意：在状态转移方程中，是从较短的字符串向长度较长的字符串进行转移的，因此一定要注意循环的顺序
 */

 /**
  * 方法：中心扩散法
  * 
  * P.S.：名字很贴切～～
  */