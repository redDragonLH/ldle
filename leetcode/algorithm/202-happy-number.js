/**
 * 202. 快乐数
 * 
 * 编写一个算法来判断一个数 n 是不是快乐数。
 * 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。
 * 如果 n 是快乐数就返回 True ；不是，则返回 False 。
 */

 /**
  * 思路： 
  *     状态：
  *         1. 数字变为1
  *         2，无限循环
  *         3. 变为无穷大
  *     注： 三位的数字不可能大于243，这意味这它要么被困在243以下的循环内，要么跌到1，四位和四位以上的数字在每一步都会丢失一位，直到降到三位为止。
  *         所以我们知道，最坏的情况下，算法可能会在 243243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 11。但它不会无限期地进行下去，所以我们排除第三种选择。
  * 
  * 算法：
  *     算法分为两步
  *         1.给一个数字n,它的下一个数字是什么
  *         2.按照一系列的数字来判断是否进入循环
  *     1. 第一部分按照题目的要求做数位分离，求平方和
  *     2. 第二部分可以使用 hashSet完成，走一步往hash 里放一个数字，如果有则说明进入循环，返回false
  */
 /**
  * hashSet 检测法 java代码
  * 
  * class Solution {
  *     // 获取每个数字的位数平方和
  *     private int getNext(int n) {
  *         int totalSum = 0;
  *         while( n > 0){
  *             int d = n % 10;
  *             n = n / 10;
  *             totalSum += d * d;
  *         }
  *         return totalSum;
  *     }
  * 
  *     public boolean isHappy(int n){
  *         set<Intger> seen = new HashSet<>();
  *         while(n != 1) !seen.contains(n) {
  *             seen.add(n);
  *             n = getNext(n);
  *         }
  *     }
  * }
  * 
  * 复杂度分析： 
  *     时间复杂度：O(243 * 3 + log n + log log n + log log log n + ...) = O(log n)
  *         * 查找给定数字的下一个值的成本为 O(log n)，因为我们正在处理数字中的每位数字，而数字中的位数由log n 给定
  *         * 要计算出总的时间复杂度，我们需要仔细考虑循环中有多少个数字，它们有多大
  *         * 我们在上面确定，一旦数字低于243，它就不可能回到243以上，因此，我们就可以用243以下最长循环的长度来代替 243，不过因为常数无论如何都无关紧要，所以无需担心
  *         * 对于高于243的n,我们需要考虑循环中每个数高于243，通过数学运算，我们可以证明在最坏的情况下，这些成本将是 O(logn)+O(loglogn)+O(logloglogn)...。幸运的是，O(log n)
  *             是占主导地位的部分，而其他部分相比之下都很小（总和小于 log n），所以可以忽略
  *     空间复杂度： O(log n) 与时间复杂度密切相关的是衡量我们放入hashSet中的数字以及它们有多大的指标，对于足够大的 n,大部分空间将由n 本身占用我们可以很容易地优化到 O(243 \cdot 3) = O(1)O(243⋅3)=O(1)，方法是只保存集合中小于 243243 的数字，因为对于较高的数字，无论如何都不可能返回到它们。
  */

  /**
   * 快慢指针法
   * 
   *    通过前一个解的代码发现 反复调用 getNext(n) 得到的是一个隐式的链表。隐式意味着我们没有实机的链表节点和指针，但数据仍然形成链表结构，起始数字是链表的头“节点”，链中的所有
   * 其他数字都是节点。next 指针通过调用 getNext(n)函数获得
   * 
   *    意识到实际上有个链表，那么这个问题就可以转换为检测一个链表是否有环，因此我们在这里可以使用弗洛伊德循环查找算法，也就是快慢针，如果是一个循环链表，快慢针最终肯定会在某个地方相遇
   * 
   * 算法：
   * 跟踪两个值，在算法的每一步中，慢速在链表中前进一个节点，快针 前进两个节点（对getNext(n)函数的嵌套调用）
   * 
   * 如果 n 是一个快乐数，既没有循环，那么快针会比慢针先到达数字1
   * 如果 n 不是一个快乐数，那么最终慢针和快针将在同一个数字上相遇
   * 
   * java 代码
   * 
   * class Solution {
   *    public int getNext(int n) {
   *        int totalSum = 0;
   *        while(n > 0) {
   *            int d = n % 10;
   *            n = n / 10;
   *            totalSum += d * d
   *        }
   *        return totalSum
   *    }
   *    public boolean isHappy(int n) {
   *        int slow = n;
   *        int fast = getNext(n);
   *        while (fast != 1 && slow != fast) {
   *            slow = getNext(slow);
   *            fast = getNext(getNext(fast))
   *        }
   *        return fast == 1;
   *    }
   * }
   * 
   * 
   * 复杂度分析： 
   *    时间复杂度： O(log n). 该分析建立在对前一种方法的分析的基础上，但是这次需要跟踪两个指针而不是一个指针来分析，以及在它们相遇钱需要绕这个循环走多少次
   *        * 如果没有循环，快针将先到达1，慢针将到达链表中的一半，最坏的情况下O(2 log n)= O(log n)
   *        * 一旦两个指针都在循环中，在每个循环中，快针将离慢针更近一步，一旦快针落后慢针一步，它们就会在下一步相遇。假设循环中有 k 个数字。如果它们的起点是相隔 k-1 的位置（这是它们可以开始的最远距离）
   *            那么快针需要 k-1步才能到达慢针处，这对与我们的目的来说也是不变的，因此，主操作仍然在计算起始n的下一个值，即O(log n)
   *    空间复杂度：O(1),对于这种方法，不需要hash 检测循环，指针需要常数记得额外空间
   */
/**
 * 数学法
 * 
 */
