/**
 * 343. 整数拆分
 *
 * 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
 */

/**
 * 动态规划思路:
 *      当正整数n >= 2时,可以拆分成至少两个正整数的和.令k是拆分出的第一个正整数,则剩下的部分是n - k ,n-k可以不继续拆分,
 * 或者继续拆分成至少两个正整数的和.那么每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积 (应该是它拆分出来的正整数的最大乘积吧)
 *      创建数组 dp,其中dp[i]表示将正整数i拆分成至少两个正整数的和之后,这些正整数的最大乘积.特别的 ,0不是正整数,1是最小的正整数,
 * 0、1都不能拆分,因此 dp[0] = dp[1] = 0
 *      当i>=2时,假设对正整数i拆分出的第一个正整数是j(1 <= j < i),则有两种方案
 *  1. 将i拆分成j和 i-j的和,且 i-j不再拆分成多个正整数,此时的乘积是 j × (i-j); // i-j 就是默认最大乘积,和dp[i-j]对比时使用
 *  2. 将 i拆分成 j 和 i- j 的和,且i-j继续拆分成多个正整数,此时的乘积是 j × dp[i-j] (计算出来的i-j对应的最大乘积)
 * 
 *      因此,当j固定时,有dp[i]=max(j × (i-j),j × dp[i-j]),由于j 的取值范围是 1 到 i-1,需要遍历所有i得到dp[i]的最大值,
 * 因此可以得到状态转移方程: dp[i] = max[1≤j<i]{max(j × (i - j),j × dp[i - j])}
 * @param {number} n
 * @return {number}
 * 
 * 就是拆分,拆完一层又一层,从最小数开始计算,而最小正整数1的最大面积是已知值,然后在往上计算,对比当前拆分数字的乘积与当前最大面积的数字
 * 
 * 总结步骤
 * 1. 数组的含义:dp[i]保存的是当前元素i与i-j(1≤j<i)对应的最大面积,也就是最大乘积(是当前整数)
 * 2. 数组元素之间的关系式: dp[i] = max[1≤j<i]{max(j × (i - j),j × dp[i - j])} ,解释如上
 * 3. 初始值:dp[0] = dp[1] = 0,dp[2] = 1
 */
var integerBreak = function (n) {
    let dp = new Array(n+1).fill(0);
    for (let i = 2; i <= n; i++) {
        let curMax = 0;
        for (let j = 1; j < i; j++) {
            curMax = Math.max(curMax,Math.max(j * (i - j),j * dp[i-j]));
        }
        dp[i] = curMax
    }
    return dp[n];
};

/**
 * 还可以用数学原理进行优化
 * 
 * 执行用时：108 ms, 在所有 JavaScript 提交中击败了6.81%的用户
 * 内存消耗：37.7 MB, 在所有 JavaScript 提交中击败了100.00%的用户
 */

 /**
  * 函数极值证明法
  */
 /**
  * 归纳证明法
  */