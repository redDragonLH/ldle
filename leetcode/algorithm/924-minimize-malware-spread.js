/**
 * 924. 尽量减少恶意软件的传播
 *
 * 给出了一个由 n 个节点组成的网络，用 n × n 个邻接矩阵图 graph 表示。在节点网络中，当 graph[i][j] = 1 时，表示节点 i 能够直接连接到另一个节点 j。
 * 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
 * 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
 * 如果从 initial 中移除某一节点能够最小化 M(initial)， 返回该节点。如果有多个节点满足条件，就返回索引最小的节点。
 * 请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后仍有可能因恶意软件传播而受到感染
 */

/**
 * 官方题解:枚举
 *  考虑每个连通分量
 *  * 如果其中没有感染节点，那么无需考虑；
 *  * 如果其中恰好有一个感染节点，移除该节点可以使得最终感染的节点数减少，减少的值即为该连通分量的大小；
 *  * 如果其中有超过一个感染节点，那么无论移除哪一个节点，剩下的那个（那些）节点总会感染连通分量中的所有节点，同样无需考虑。
 *
 *
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function (graph, initial) {
  const n = graph.length;
  let ids = new Array(n).fill(0);
  let idToSize = new Map();
  let id = 0;
  for (let i = 0; i < n; ++i) {
    if (!ids[i]) {
      ++id;
      let size = 1;
      let q = [i];
      ids[i] = id;
      while (q.length > 0) {
        let u = q.shift();
        for (let v = 0; v < n; ++v) {
          if (!ids[v] && graph[u][v] === 1) {
            ++size;
            q.push(v);
            ids[v] = id;
          }
        }
      }
      idToSize.set(id, size);
    }
  }
  let idToInitials = new Map();
  for (const u of initial) {
    if (!idToInitials.has(ids[u])) {
      idToInitials.set(ids[u], 0);
    }
    idToInitials.set(ids[u], idToInitials.get(ids[u]) + 1);
  }
  let ans = n + 1,
    ansRemoved = 0;
  for (const u of initial) {
    let removed = idToInitials.get(ids[u]) === 1 ? idToSize.get(ids[u]) : 0;
    if (removed > ansRemoved || (removed === ansRemoved && u < ans)) {
      ans = u;
      ansRemoved = removed;
    }
  }
  return ans;
};
