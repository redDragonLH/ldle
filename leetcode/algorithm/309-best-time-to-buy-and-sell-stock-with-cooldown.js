/**
 * 309. 最佳买卖股票时机含冷冻期
 * 
 * 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​
 * 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
 * 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
 * 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
 */

/**
 * 官方方法 动态规划
 * 
 * 思路：
 *  由于每天最多只能同时买入（持有）一支股票，并且卖出股票后又冷冻期的限制，因此会有三种状态
 *      * 目前持有一支股票，对应的累计最大收益记为 f[i][0]
 *      * 目前不持有任何的股票，并且处于冷冻期，对应的 累计最大收益 记为 f[i][1]
 *      * 目前不持有任何股票,并且不处于冷冻期中，对应的累计最大收益 记为 f[i][2]
 * 
 *  状态转移：，在第 i 天的时候，可以在不违反规则的前提下进行 买入 或 卖出 操作，此时第 i 天的状态
 * 会从第 i-1 天的状态转移而来；不进行任何操作，此时第 i 天的状态就等同于第i天的状态
 * 
 * 三种状态的分析
 *      * 对于f[i][0]，目前持有的这一支股票可以是在第i-1天就已经持有的，对应的状态为f[i-1][0]；
 * 或者是第i 天买入的，那么第 i-1 天就不能持有股票并且不处于冷冻期中，对应的状态为 f[i - 1][2]加上
 * 买入股票的负收益 prices[i]。因此状态转移方程为： f[i][0] = max(f[i - 1][0],f[i - 1][2]- prices[i])
 * 
 *      * 对于f[i][1],在第i天结束之后处于冷冻期的原因是在当天卖出了股票，那么说明在第 i - 1天时我们必须持有
 * 一支股票，对应的状态 f[i - 1][0]加上卖出股票的正收益 prices[i] 。因此状态转移方程为： f[i][1] = f[i-1][0] + prices[i]
 * 
 *      对于f[i][2]，在第i 天结束之后不持有任何股票并且不处于冷冻期，说明当天没有进行任何操作，
 * 即第 i - 1 天不持有任何股票；如果处于冷冻期，对应的状态为 f[i-1][1];如果不处于冷冻期，
 * 对应的状态为f[i-1][2]。因此状态转移方程： f[i][2] = max(f[i - 1][1],f[i - 1][2])
 * 
 * 这样就得到了所有的状态转移方程。如果一共有n天，那么最终的答案即为：max(f[n-1][0],f[n-1][1],f[n-1][2]),单手
 * 在最后一天（第 n -1 天）结束之后，手上仍然持有股票，那么显然是没有任何意义的，因此最公式是： max(f[n−1][1],f[n−1][2])
 * 
 * 初始条件：
 * f[0][0] = -prices[0],f[0][1] = 0,f[0][2]=0
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    let len = prices.length
    if(!len) return 0;

    let f = new Array(len)
    f.fill([]);
    f = f.map(e=>{
        return new Array(0,0,0)
    })
    f[0][0] = -prices[0];
    for (let i = 1; i < len; i++) {
        f[i][0] = Math.max(f[i - 1][0],f[i - 1][2]-prices[i]);
        f[i][1] = f[i - 1][0] + prices[i];
        f[i][2] = Math.max(f[i - 1][1],f[i - 1][2]);
    }
    return Math.max(f[len - 1][1],f[len - 1][2])
};
console.log(maxProfit([1,2,3,0,2]));

/**
 * 动态规划不一定要每个位置就计算出一个总的数据，状态太多可以分开计算？但是得能弄明白分开的状态与最后的结果的关系，太难
 * 
 * 推导这个太复杂了，还以为是每个元素都要计算出一个数值，没想到是内部状态分开计算
 * 
 * 有三个状态，所以有了三个位置，保存每个状态位置的数据
 */