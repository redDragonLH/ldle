/***
 * 1186. 删除一次得到子数组最大和
 *
 * 给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。
 * 换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，
 * 然后该子数组（剩下）的元素总和是所有子数组之中最大的。
 *
 * 注意，删除一个元素后，子数组 不能为空。
 */

/**
 * 思路比较简单,毕竟子数组可以等于整个数组,不过有负数,元素相等等问题,导致边界条件过多,不能简单的把整个数组减去一个元素,
 * 但是遍历感觉又有点效率低
 * 
 * 动态规划
 * 
 * 求解以 arr[i]结尾的最多删除一次的非空子数组的最大和.以dp[i][k]表示以arr[i]结尾,删除 k 次的非空子数组的最大和(删除前的末尾元素为arr[i],就视为以 arr[i]结尾).
 * 初始时 dp[0][0] = arr[0],dp[0][1]=0 (以 arr[0]结尾,删除一次的非空子数组不存在,因此dp[0][1]不会计入结果).
 * 
 * 转移方程
 *  dp[i][0] = max(dp[i-1][0],0)+ arr[i]
 *  dp[i][0] = max(dp[i-1][1] + arr[i],dp[i-1][0])
 * 
 *  第一个转移方程表示在不删除的情况下,以 arr[i] 为结尾的非空子数组的最大和 dp[i][0] 与 dp[i-1][0]有关,当dp[i-1][0] > 0 时,
 * 直接将 arr[i]与i-1时的最大非空子数组连接时,取得最大和,否则只选 arr[i]时,取得最大和
 *  第二个转移方程表示在删除一次的情况下,以arr[i]为结尾的非空子数组有两种情况
 *      1. 不删除 arr[i],那么选择 arr[i] 与dp[i-1][1]对应的子数组(已执行一次删除)
 *      2. 删除 arr[i],那么选择 dp[i-1][0]对应的非空子数组(未执行一次删除,但是等同与删除了arr[i])
 * @param {number[]} arr
 * @return {number}
 */
var maximumSum = function (arr) {
  let dp0 = arr[0],
    dp1 = 0,
    res = arr[0];
  for (let i = 1; i < arr.length; i++) {
    dp1 = Math.max(dp0, dp1 + arr[i]);
    // 前面是负数就丢弃,负数+啥都是变小
    dp0 = Math.max(dp0, 0) + arr[i];
    res = Math.max(res, Math.max(dp0, dp1));
  }
  return res;
};
