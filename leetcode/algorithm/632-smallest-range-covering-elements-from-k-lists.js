/**
 * 632. 最小区间
 * 
 * 你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。
 * 我们定义如果 b-a < d-c 或者在 b-a == d-c 时 a < c，则区间 [a,b] 比 [c,d] 小
 */

/**
* @param {number[][]} nums
* @return {number[]}
*/
var smallestRange = function (nums) {

};

/**
 * 官方题解 堆
 * 
 * 给定K个列表，找到最小区间，使得每个列表都至少有一个数在该区间中，该问题可以转化为，从k个列表中
 * 各取一个数，使得这 k个数中的最大值与最小值的差最小  （这是怎么转化的~~~~这是一个意思？？？）
 * 
 * 假设这K个数中的最小值是第i个列表中的x，对于任意 j ≠i，设第j个列表中被选为k个数之一的数是y，
 * 则为了找到最小区间，y应该取第 j 个列表中大于 等于 x 的最小数。
 *      证明： 假设  z 也是第 j 个列表中的数，且 z > y，则有 z - x > y - x,同时包含 x 和 z的区间一定不会小于同时包含 x 和 y的区间.
 * 因此，其余 k -1 个列表中应该取大于等于x的最小的数
 * 
 * 由于k个列表都是升序排列的，因此对每个列表维护一个指针，通过指针得到列表中的元素，指针右移之后
 * 指向的元素一定大于或等于之前的元素
 * 
 *      使用最小堆维护 k 个指针指向的元素中的最小值，同时维护堆中元素的最大值。
 * 初始时，k个指标都指向下标 0，最大元素即为所有列表的下标 0 位置的元素中的最大值。
 * 每次从堆中取出最小值，根据最大值和最小值计算当前区间，如果当前区间小于最小区间则用当前区间更新最小区间
 * 然后将对应列表的指针右移，将新元素加入堆中，并更新堆中元素的最大值
 * 
 *      如果一个列表的指针超出该列表的下标范围，则说明该列表中的所有元素都被遍历过，
 * 堆中不会再有该列表中的元素，直接退出循环
 */