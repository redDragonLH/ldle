/**
 * 675. 为高尔夫比赛砍树
 *
 * 你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 m x n 的矩阵表示， 在这个矩阵中：
 *  * 0 表示障碍，无法触碰
 *  * 1 表示地面，可以行走
 *  * 比 1 大的数 表示有树的单元格，可以行走，数值表示树的高度
 *
 * 每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。
 * 你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 1（即变为地面）。
 * 你将从 (0, 0) 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 -1 。
 * 可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。
 */

/**
 * 核心问题是是否有障碍把一些树完全包起来或者完全隔开
 *
 * 检查0是否构成分割,分割之内是否包含树,比较麻烦
 *
 * 哦,主要问题是最小步数~~
 * 那其实可以把所有步数遍历,然后小到大遍历,检查是否有无法达到的数字 (非等差数列比较较为复杂)
 * @param {number[][]} forest
 * @return {number}
 */
var cutOffTree = function (forest) {};

/**
 * 官方题解: 广度优先搜索
 * 
 * 首先对矩阵中的树按照树的高度进行排序,依次求出相邻的树之间的最短距离.利用广度优先搜索,按照层次遍历,处理队列中的节点(网格位置). 
 * visited 记录在某个时间点已经添加到队列中的节点.这些节点已被处理或在等待处理的队列中.对于下一个要处理的每个节点,查看他们的四个方向上相邻的点,如果相邻的点没有被遍历过且不是障碍,
 * 将其加入到队列中,知道找到终点为止,返回当前的步数即可.最终返回所有的步数之和即为最终结果
 * @param {number[][]} forest
 * @return {number}
 */
var cutOffTree = function (forest) {};

