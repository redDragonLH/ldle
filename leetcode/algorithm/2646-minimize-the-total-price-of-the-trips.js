/**
 * 2646. 最小化旅行的价格总和
 * 
 * 现有一棵无向、无根的树，树中有 n 个节点，按从 0 到 n - 1 编号。给你一个整数 n 和一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条边。
 * 每个节点都关联一个价格。给你一个整数数组 price ，其中 price[i] 是第 i 个节点的价格。
 * 给定路径的 价格总和 是该路径上所有节点的价格之和。
 * 另给你一个二维整数数组 trips ，其中 trips[i] = [starti, endi] 表示您从节点 starti 开始第 i 次旅行，并通过任何你喜欢的路径前往节点 endi 。
 * 在执行第一次旅行之前，你可以选择一些 非相邻节点 并将价格减半。
 * 返回执行所有旅行的最小价格总和。
 */
/**
 * 
 * 主要问题在于可以将非相邻节点价格减半,这个非相邻节点可能是非黑即白的,那就简单很多,但是如果为了最大效用,可能出现非连续和非规律的减半情况
 * 
 * 如果是规律的和非黑即白的,那么一个节点就只会有减或不减两种情况然后向外规律扩展,得到整体的价格,获得最小的总值
 * 
 * 如果是不规律的 ,那么要考虑使用动态规划计算所有情况,获取最小的总值
 * @param {number} n
 * @param {number[][]} edges
 * @param {number[]} price
 * @param {number[][]} trips
 * @return {number}
 */
var minimumTotalPrice = function(n, edges, price, trips) {

};