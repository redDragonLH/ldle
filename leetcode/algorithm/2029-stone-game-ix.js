/**
 * 2029. 石子游戏 IX
 *
 * Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 stones ，其中 stones[i] 是第 i 个石子的价值。
 *
 * Alice 和 Bob 轮流进行自己的回合，Alice 先手。每一回合，玩家需要从 stones 中移除任一石子。
 *  * 如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 3 整除，那么该玩家就 输掉游戏 。
 *  * 如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。
 *
 * 假设两位玩家均采用 最佳 决策。如果 Alice 获胜，返回 true ；如果 Bob 获胜，返回 false 。
 */
/**
 * 也就是查找一种顺序使之部分元素之和不能被3整除,但是顺序不一样,最后结果是一样的吧,当然,可能结果不符合条件,但是中间结果符合
 *
 * 比较直观的方案就是交替获取元素,使用两个贪心逻辑
 * 
 * 不对,应该是同一个贪心逻辑,都在查找能被3整除的数,现在问题是怎么算最佳决策
 * @param {number[]} stones
 * @return {boolean}
 */
var stoneGameIX = function (stones) {
  let user = 0;
  let len = stones.length;
  let count = 0;
  while (len--) {
    if (user) {
      for (const item of stones) {
        if (item > 0 && !(count + item) % 3) return false;
      }
      for (let i = 0; i < stones.length; i++) {
        if (stones[i] > 0) {
          count += stones[i];
          stones[i] = 0;
          break;
        }
      }
    } else {
      let oldCount = count;
      for (let i = 0; i < stones.length; i++) {
        if (stones[i] > 0&& (count + stones[i]) % 3) {
          count += stones[i];
          stones[i] = 0;
          break;
        }
      }
      if (oldCount == count) return false;
    }
    user = (user + 1) % 2;
  }
  return true;
};


/**
 * 官方题解: 构造
 * 博弈论
 * 
 * 思路: 由于玩家的目标是使得已经被移除的石子总和不是3的倍数,因此可以把石子分成三类,他们的价值除以3的余数分别为0,1,2 . 可以
 * 直接用0,1,2代表它们的价值,对应的石子数量分别为 cnt0,cnt1,cnt2
 * 
 *  可以发现,移除类型0的石子并不会对总和产生影响,因此类型0的石子可以看作是「先后手」交换.
 *      例: 当前玩家操作时,发现如果自己选择移除类型1或2的石子,那么她在最后一定不能获胜.这时它就可以选择移除一个类型0的石子,
 *          将同样的局面交给对手.如果类型0的石子还没有移除完,那么对手同样可以通过移除一个类型0的石子将局面重新交给玩家.这样
 *          不断往复下去
 *  可得: 
 *      * 如果类型0的石子的个数为偶数,那么胜负情况等驾驭没有类型0的石子的胜负情况
 *      * 如果类型0的石子个数为奇数,那么胜负情况等驾驭只有1个类型0的石子的胜负情况
 * 
 *  为了保证移除石子的和不为3的倍数.操作顺序只有可能是以下两种情况
 *      * 如果 Alice首先移除类型1的石子,那么Bob只能移除类型1的石子,,在这之后Alice只能移除类型2的石子,以此类推
 *          移除石子的类型序列为: 1121212121.....
 *      * 如果 Alice 首先移除类型2的石子,可以得到移除石子的类型顺序为: 2212121212....
 * 
 *  作为先手的Alice可以在二者中选择一个序列.例如Alice选择第一种,那么Bob永远移除类型1的石子,Alice除了第一步移除
 * 类型1的石子之外,后续永远移除类型2的石子.因此Alice 可以获胜当且仅当:
 *      * 类型1的石子恰好有1个,并且类型2的石子至少有1个.此时 Alice在Bob完成第一步时获胜
 *      * 类型1的石子至少有2个,并且不能比类型2的石子多:
 *          * 如果多1个,那么Alice 移除最后一个类型2的石子后,所有石子都被移除,Bob获胜
 *          * 如果多2个,那么在Bob 移除最后一个类型1的石子后,所有的石子都被移除,Bob获胜;
 *          * 如果多超过2个,那么Alice 会在某一步没有类型2的石子可以移除,Bob 获胜;
 *          * 如果一样多或类型2的石子更多,那么Bob会在某一步没有类型1的石子可以移除,Alice获胜
 * 
 *      上面两个条件可以归纳为同一个条件,即有类型1的石子,并且不能比类型2的石子多
 * 
 *  同理,如果Alice 选择第二种,那么它获胜当且仅当类型2的石子,并且不能比类型1的石子多
 * 
 * 细节:
 *      回到前面关于类型0石子的讨论,可以得道Alice获胜的条件
 *      * 如果类型0的石子的个数为偶数,那么Alice获胜当且仅当类型1和类型2的石子至少都有1个
 *      * 如果类型 00 的石子的个数为奇数，那么 Alice 获胜当且仅当「在没有类型 00 石子的情况下，Bob 获胜且原因不是因为所有石子都被移除」。对应到上面的分析即为「类型 11 的石子比类型 22 多超过 22 个」或者「类型 22 的石子比类型 11 多超过 22 个」。
 * 
 * 光着前半部分解题思路就够吸收一会了
 */