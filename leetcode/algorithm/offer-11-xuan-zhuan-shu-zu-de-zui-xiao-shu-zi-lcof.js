/**
 * 剑指 Offer 11. 旋转数组的最小数字
 * 
 * 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。
 * 例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。
 */

/**
 * 思路:
 *  除了暴力循环,还可以使用二分法
 *  每次获取中间元素,查看是否小于数组最前边的元素
 *      如果小于则小于大于等于最小元素
 *      如果大于最前边的元素,则最小元素在当前元素的左边
 * @param {number[]} numbers
 * @return {number}
 */
/**
 * 官方题解是以数组最后一个元素为标杆:最小值右侧的元素，它们的值一定都小于等于 x；而在最小值左侧的元素，它们的值一定都大于等于 x
 *  
 * 在二分对比时以右侧位置为主,用中间点与右侧点进行对比
 *      * 第一种情况:右侧元素大于中间点元素说明 中间点是在最小点右侧的元素,舍弃右侧所有元素
 *      * 第二种情况: 右侧元素小于中间点元素,说明中间点是最小点左侧的元素,舍弃左侧
 *      * 第三种情况:右侧元素等于中间点元素.由于重复元素的存在，我们并不能确定 中间点元素 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论 右侧点 是不是最小值，都有一个它的「替代品」中间点，因此我们可以忽略二分查找区间的右端点。
 * 
 * 备注:
 *      * left的话需要单独考虑完全升序排列
 * 
 */
var minArray = function(numbers) {
    const len = numbers.length;
    if(!len) return 0;
    let i = 0;
    let j = len-1;
    while(i < j){
        let m = parseInt((i + j) / 2);
        if (numbers[m] > numbers[j]) i = m + 1;
        else if (numbers[m] < numbers[j]) j = m;
        else j--;
    }
    
    return numbers[i];
};

/**
 * 换个思路 查找最大的元素,那么最小的元素就在他右边
 * @param {*} numbers 
 */
// var minArray = function(numbers) {
// };
console.log(minArray([3,1,1]));
console.log(minArray([3,4,5,1,2]));
