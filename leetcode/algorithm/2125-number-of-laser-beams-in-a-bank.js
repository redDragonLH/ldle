/**
 * 2125. 银行中的激光束数量
 * https://leetcode.cn/problems/number-of-laser-beams-in-a-bank/
 * 银行内部的防盗安全装置已经激活。给你一个下标从 0 开始的二进制字符串数组 bank ，表示银行的平面图，这是一个大小为 m x n 的二维矩阵。 bank[i] 表示第 i 行的设备分布，由若干 '0' 和若干 '1' 组成。'0' 表示单元格是空的，而 '1' 表示单元格有一个安全设备。
 * 对任意两个安全设备而言，如果同时 满足下面两个条件，则二者之间存在 一个 激光束：
 *  * 两个设备位于两个 不同行 ：r1 和 r2 ，其中 r1 < r2 。
 *  * 满足 r1 < i < r2 的 所有 行 i ，都 没有安全设备 。
 * 激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。
 * 返回银行中激光束的总数量。
 */
/**
 * 最简单的方案就是按层两层计算，也不只是两层，中间最多有n-2层,那么这个算法时间消耗就很高了，
 * 一行一行匹配是最简单的办法，但是事件复杂的过高
 *
 * 有一个新的思路，在新一行数据计算之前，将之后的所有行数据压缩成一行，然后计算当前行和压缩行的连接数
 * @param {string[]} bank
 * @return {number}
 */
var numberOfBeams = function (bank) {};
/**
 * 官方题解：直接计数
 *
 * 根据题目的要求，对于两个不同的行 r1 和 r2 (r1 < r2)，
 * 如果它们恰好是相邻的两行（即 r1 + 1 = r2），或者它们之间的所有行都全为 0，
 * 那么第 r1 行的任意一个安全设备与第 r2 行的任意一个安全设备之间都有激光束。
 *
 * 
 * 因此，我们只需要统计每一行的安全设备个数，记为 cnt，以及上一个不全为 0 的行的安全设备个数，
 * 记为 last。那么 cnt×last 即为激光束的个数。我们对所有的行进行遍历，
 * 维护 cnt 和 last 并对 cnt×last 进行累加，即可得到激光束的总数量。
 * @param {string[]} bank
 * @return {number}
 */
var numberOfBeams = function (bank) {
  let last = 0,
    ans = 0;
  for (const line of bank) {
    const cnt = (line.match(/1/g) || []).length;
    if (cnt !== 0) {
      ans += last * cnt;
      last = cnt;
    }
  }
  return ans;
};
/**
 * 简洁~
 * 执行用时：34 ms, 在所有 JavaScript 提交中击败了15.79%的用户
 * 内存消耗：66.02 MB, 在所有 JavaScript 提交中击败了26.32%的用户
 */
