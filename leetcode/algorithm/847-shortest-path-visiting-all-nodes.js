/**
 * 847. 访问所有节点的最短路径
 *
 * 存在一个由 n 个节点组成的无向连通图，图中的节点按从 0 到 n - 1 编号。
 *
 * 给你一个数组 graph 表示这个图。其中，graph[i] 是一个列表，由所有与节点 i 直接相连的节点组成。
 *
 * 返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。
 */

/**
 * 
 * 直接思路就是递归,每次递归走一步(包含所有分支节点与后退),最后比较最小的步数,
 * 但是这样每个元素都要循环到,每个节点都要重复遍历 graph.length 次,不呢个
 * @param {number[][]} graph
 * @return {number}
 */
var shortestPathLength = function (graph) {};



/**
 * 官方题解 状态压缩 + 广度优先搜索
 * 
 * 最短路径的前提是「访问了所有节点」,因此除了记录节点的编号以外,还需要记录每一个节点的经过情况,
 * 使用三元组(u,mask,dist)表示队列中的每一个元素:
 *      * u表示当前位置的节点编号
 *      * mask 是一个长度为n的二进制数,表示每一个节点是否经过,如果mask 的第i位是1,则表示节点i已经过,否则表示节点i未经过(会有重复经过的节点吧)
 *      * dist 表示到当前节点为止经过的路径长度
 * 
 * 使用该三元组进行广度优先搜索,初始时,将所有的(i,2^i,0)放入队列,表示可以从任一节点开始,在搜索过程中,如果当前三元组的 mask 包含n 个1(即mask = 2^n-1),就可以返回dist作为答案
 */