# 用三个水桶等分 8 升水的问题
```
题目：有三个分别是 3 升、5 升和 8 升容积的水桶，其中容积为 8 升的水桶中装满了水，容积为 3 升和容积为 5 升的水桶是空的，三个水桶都没有体积刻度。现在需要把大水桶中的 8 升水等分成两份，每份都是 4 升水，附加条件是只能使用这 8 升水和另外两个空水桶，不能借助其他容器或更多的水。
```

穷举法设计算法的两个步骤：
* 确定问题的解（或状态）的定义，解空间的范围以及正确解的判定条件；
* 根据解空间的特点选择搜索策略，逐个检验解空间中的候选解是否正确，必要时可辅助一些剪枝算法，排除一些明显不可能是正确解的检验过程，提高穷举的效率

## 定义问题的状态

把某一时刻三个水桶中的水量视为一个状态，将倒水动作的变化转化为三个水桶中水的状态的变化，问题的解空间就是水桶状态的全部集合，正确解的判定条件就是容量为 8 升的水桶和容量为 5 升的水桶中各有 4 升水。如果用一个三元组（或是三维向量）分别表示 8 升、5 升和 3 升水桶中的水量，则问题的初始状态就是 [8，0，0]，问题的解决状态就是 [4，4，0]。

算法本质上就是对状态的穷举搜索，这样的状态变化搜索的结果通常是得到一棵状态搜索树，根节点是初始状态，叶子节点可能是最终状态，也可能是某个无法转换到最终状态的中间状态，状态树有多少个最终状态的叶子节点，就有多少种答案。由此可知，解决本问题的算法关键是建立状态和动作的数据模型，并找到一种持续驱动动作产生的搜索方法。

## 状态树和解空间
倒水动作与静止状态的结合就产生了状态变化，持续的状态变化就产生了一棵状态树，这个状态树上的所有状态就构成了穷举算法的解空间
![倒水问题的状态树](../img/倒水问题的状态树.png)

[8，0，0] 是状态树的根，图（1）只画出了这棵状态树的一部分，图中深颜色背景标识出的几个状态是状态树的一个分支，也是一个正确的解的状态转换路径。根据题目的意图，最终的结果是要输出这条转换路径的倒水过程，实际上就是与状态转换路径相对应的动作路径，或动作列表（图（1）中蓝色文字描述的倒水动作序列）。当定义了动作的数学模型后，就可以根据状态图中状态转换路径找到对应的动作列表，依次输出这个路径上每个状态对应的动作就可以得到一个完整的倒水过程。

### 状态的数据模型

以桶为单位，把容积和水量一起考虑
```
class Bucket
{
    ......
    int m_water;  //当前水量
    int m_capicity;  //桶的容积
};
```
表示三个水桶的三维向量用数组表示，`std::vector<...> `是 C++ 的数组，其类型就是前面定义的 Bucket。水的状态就是桶的状态：
```
class BucketsState
{
......
    std::vector<Bucket> m_buckets;  //桶的向量
    ACTION m_curAction;  //当前状态对应的动作
};
```
`m_curAction` 是当前状态绑定的倒水动作，即前一个状态通过这个倒水动作演变成当前状态，它并不是状态穷举过程中的关键属性，记录这个状态对应的倒水动作的目的是为了能够在输出结果时，除了输出三个水桶的状态变化序列，还能够输出对应的倒水动作

### 倒水动作的数据模型
一个合法的倒水动作包含三个要素：源水桶编号、目的水桶的编号和倒水的量（体积）。我们用一个三元组来描述倒水动作：{from, to, water}，from 是指源水桶的编号，to 是指目的水桶的编号，water 是此次倒水动作所倒的水量。倒水动作的数据结构定义如下：

```
typedef struct
{
    int from;
    int to;
    int water;
}ACTION;
```
![](../img/状态演变过程与倒水动作关系图.png)

## 设计搜索算法