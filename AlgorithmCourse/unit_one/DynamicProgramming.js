/**
 * 动态规划
 *
 */

/**
 * 最长公共子序列（LCS）问题
 *
 * 问题：
 * 最长公共子序列也称作最长公共子串，其定义是：一个序列 S，如果分别是两个或多个已知序列的子序列，且是符合此条件的子序列中最长的，则称 S 为已知序列的最长公共子序列。关于子序列的定义通常有两种方式，一种是对子序列没有连续的要求，其子序列的定义就是原序列中删除若干元素后得到的序列；另一种是对子序列有连续的要求，其子序列的定义是原序列中连续出现的若干个元素组成的序列。求解子序列是非连续的最长公共子序列问题，也是一个十分实用的问题，它可以描述两段文字之间的“相似度”，即它们的雷同程度，从而能够用来辨别抄袭。下面来将绍对子序列没有连续性要求的情况下应如何用动态规划法来解决最长公共子序列问题。
 *
 * 字串是连续的，子序列可以是不连续的
 */

/**
 * to https://segmentfault.com/a/1190000012864957#articleHeader6
 */
function LCS( str1, str2 ){
  var rows = str1.split(''); // 按照单字符分成数组
  rows.unshift(''); // 头部插入一个空字符
  var cols = str2.split('');
  cols.unshift('');
  var m = rows.length,
      n = cols.length,
      dp = []; // 组成一个二维数组 
  for (var i = 0; i < m; i++) {
    dp[i] = []; // 定义二维数组(第一维是rows 的下标，第二维是cols 的下标，保存的数据是 从开始到现在的相等的字符的数量)
    for (var j = 0; j < n; j++) {
      if( i === 0 || j === 0 ){
        dp[i][j] = 0; // 跳过第一个元素（第一个元素都是 空字符吧，那为什么要插入呢）
        continue; // 跳到下次循环
      }
      if(rows[i] === cols[j]){ // 如果两个数组中对应元素相等
        dp[i][j] = dp[i-1][j-1] + 1; //  对角 +1， 已经是第几个相等的字符吧
      }else{
        dp[i][j] = Math.max( dp[i-1][j],dp[i][j-1] ); // 没增加，保持以前的数据
      }
    }
  }
   return dp[i-1][j-1]; // 最后的数据就是最长公共字串的数量
}