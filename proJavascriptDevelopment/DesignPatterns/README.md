# 设计模式集合
## FormFieldFactory
  **工厂模式**  
      实现不指定特定的“类”而创建对象，利用工厂模式，对象的创建处理过程被予以抽象，使得相对复杂的对象创建处理过程得以封装于简单的接口之下，而不需要 new 关键字。此抽象意味着，用作创建各实例的后台 “类”的类型和方法可以随时被完全替换，而不需要改变接口来适应 “类”的创建。其他人并不需要理解接口底下所发生的变化  
      如果预知到在将来可能需要做出许多更改，但又不希望必须重写散步在大量其他代码中的“类”的实例代码，则使用工厂模式是很理想的做法
##abstractFactory
  **抽象工厂模式**  
  它可以创建一个额外的抽象层，根据共同的用处或主题来一起创建出多个工厂，将两个工厂作为一个新的工厂类型的实例来对待，这两个工厂享有相似的行为  
##builder
**生成器模式**  
  生成器模式抽象了对象的创建过程，再次模式中，只需要提供我们所希望创建的对象的内容和类型即可，而决定使用哪个“类”来进行对象创建的处理工作则有生成器抽象了出来。通过把创建过程划分为一系列的较小的步骤，便可以有效的完成一个完整的对象的创建，最后调用一个操作来“生成”预期的对象，并将其返回给发出调用的代码。一个生成器中可以潜在性地包含大量地代码，应用所有地这些内容地明确目的是为了让开发人员尽可能轻松地进行对象创建
##prototype  
  **原型模式**  
  通过使用原型继承克隆已存在的对象来创建新的对象。原型继承是javascript贯穿创建过程的继承类型，实现方法有两种：一种是使用一个已经存在的对象的prototype属性；第二种是使用ECMAScript 5 的Object.create()方法
##singleton  
  **单例模式**  
  定义一个对象的创建过程，此对象只有一个单独的实例，单例模式的最简单形式可以是一个简单的对象直接量，其中封装了特定的相关行为
##adapter
  **适配器模式**  
  适配器模式就是使用函数关联两个组件，尤其在重构代码新的API替换旧的API之时非常有用，因为很简单，所以就不写例子了，尤其是已经理解的情况下
##composite
  **组合模式**
  为一个或多个对象创建了一个接口，使终端用户不需要知道所需要处理的对象的个数，
##decorator
  **装饰模式**
  用于为某个“类”创建的对象扩展和定制额外的方法和属性，避免因创建大量的子类而变得难以维护。  
  实现方法是：通过有效的将对象包装在另一个对象中，此另一个对象实现了相同的公共方法，更加我们所需要的行为对相关方法进行重写
##facade
  **外观模式**
  通过编写一个单独的函数，来简化对一个或多个更大型、可能更复杂的函数的访问
##flyweight
  **享元模式**
  一种关于优化的模式。使用少量可共享的对象来替代大量相类似对象，使得代码的运行占用内存更少并更为高效
