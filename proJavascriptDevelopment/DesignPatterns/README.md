# 设计模式集合
## FormFieldFactory
  **工厂模式**  
      实现不指定特定的“类”而创建对象，利用工厂模式，对象的创建处理过程被予以抽象，使得相对复杂的对象创建处理过程得以封装于简单的接口之下，而不需要 new 关键字。此抽象意味着，用作创建各实例的后台 “类”的类型和方法可以随时被完全替换，而不需要改变接口来适应 “类”的创建。其他人并不需要理解接口底下所发生的变化  
      如果预知到在将来可能需要做出许多更改，但又不希望必须重写散步在大量其他代码中的“类”的实例代码，则使用工厂模式是很理想的做法
## abstractFactory
  **抽象工厂模式**  
  它可以创建一个额外的抽象层，根据共同的用处或主题来一起创建出多个工厂，将两个工厂作为一个新的工厂类型的实例来对待，这两个工厂享有相似的行为  
## builder
**生成器模式**  
  生成器模式抽象了对象的创建过程，再次模式中，只需要提供我们所希望创建的对象的内容和类型即可，而决定使用哪个“类”来进行对象创建的处理工作则有生成器抽象了出来。通过把创建过程划分为一系列的较小的步骤，便可以有效的完成一个完整的对象的创建，最后调用一个操作来“生成”预期的对象，并将其返回给发出调用的代码。一个生成器中可以潜在性地包含大量地代码，应用所有地这些内容地明确目的是为了让开发人员尽可能轻松地进行对象创建
## prototype  
  **原型模式**  
  通过使用原型继承克隆已存在的对象来创建新的对象。原型继承是javascript贯穿创建过程的继承类型，实现方法有两种：一种是使用一个已经存在的对象的prototype属性；第二种是使用ECMAScript 5 的Object.create()方法
## singleton  
  **单例模式**  
  定义一个对象的创建过程，此对象只有一个单独的实例，单例模式的最简单形式可以是一个简单的对象直接量，其中封装了特定的相关行为
## adapter
  **适配器模式**  
  适配器模式就是使用函数关联两个组件，尤其在重构代码新的API替换旧的API之时非常有用，因为很简单，所以就不写例子了，尤其是已经理解的情况下
## composite
  **组合模式**
  为一个或多个对象创建了一个接口，使终端用户不需要知道所需要处理的对象的个数，
## decorator
  **装饰模式**
  用于为某个“类”创建的对象扩展和定制额外的方法和属性，避免因创建大量的子类而变得难以维护。  
  实现方法是：通过有效的将对象包装在另一个对象中，此另一个对象实现了相同的公共方法，更加我们所需要的行为对相关方法进行重写
## facade
  **外观模式**
  通过编写一个单独的函数，来简化对一个或多个更大型、可能更复杂的函数的访问
## flyweight
  **享元模式**
  一种关于优化的模式。使用少量可共享的对象来替代大量相类似对象，使得代码的运行占用内存更少并更为高效
## Mixin
  **掺和模式**
  通过快速并简易地从一个对象中把一组方法和属性直接应用至其他对象，或应用至“类”地prototype，使该类地所有对象实例都能够访问这些属性和方法，从而避免了产生大量子类和继承链地需要
## module
  **模块模式**
  基于自执行函数闭包，使得我们可以建立一个代码的安全沙箱区域，在其中可以访问全局变量和函数，但不会把在它里面声明的变量和函数暴露给它周围的作用域，除非使明确的使用return 语句
  ` 当希望把大型代码的代码库分解为更小的、更易管理的、自我包含的多个组成部分，而每个部分有明确的依赖项，每部分有清晰定义的使用目的，使用模块模式最为合适。因为它们的沙箱特性，它们的自执行函数代码块同时也是通过混淆和缩编来生成更小的文件的主要代码 `
## proxy
  **代理模式**
  通过定义一个代理对象的方法来替换或增强一个已经存在的对象或方法，以提升其性能或增加额外的功能，但又不影响已经使用了该对象或方法的其余部分代码
# 行为型设计模式
## 职责链模式
当基于一个相同的“类”的若干个类可以相应的处理某项请求或调用时，可以使用职责链(chain of responsibility)模式。该项请求首先会发送至一个对象，如果该对象不是能处理该请求的最合适对象，则会把该请求传递至另一个对象进行处理。这样传递就会不断进行，直至到达可以处理该请求的对象。然后通过此职责链各对象的操作处理所得的结果会返回给原来的请求或方法调用。  
职责链中的每一个对象都认识其他一个对象，如果一个对象不能亲自处理到达的请求，就会由职责链中的下一继任对象来处理。当多个对象在一起时能组合成某种类型的层级关系，但又不希望向代码的其他部分暴露其中的实现过程，则此时使用职责链模式最为合适
